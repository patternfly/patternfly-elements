let t=()=>null;function e(){t("[reveal] web components ready"),t("[reveal] elements ready, revealing the body"),window.document.body.removeAttribute("unresolved")}
/*!
 * PatternFly Elements: PFElement 1.0.0-prerelease.55
 * @license
 * Copyright 2020 Red Hat, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
*/const s="pfe-";class i extends HTMLElement{static create(t){window.customElements.define(t.tag,t)}static debugLog(t=null){return null!==t&&(i._debugLog=!!t),i._debugLog}static log(...t){i.debugLog()&&console.log(...t)}static get PfeTypes(){return{Container:"container",Content:"content",Combo:"combo"}}static get version(){return"{{version}}"}static get observedAttributes(){return["pfe-theme"]}get randomId(){return"pfe-"+Math.random().toString(36).substr(2,9)}get version(){return this._pfeClass.version}get pfeType(){return this.getAttribute(`${s}type`)}set pfeType(t){this.setAttribute(`${s}type`,t)}cssVariable(t,e,s=this){return t="--"!==t.substr(0,2)?"--"+t:t,e&&s.style.setProperty(t,e),window.getComputedStyle(s).getPropertyValue(t).trim()}has_slot(t){return this.querySelector(`[slot='${t}']`)}has_slots(t){return[...this.querySelectorAll(`[slot='${t}']`)]}context_update(){const t=this.querySelectorAll("[pfelement]");let e=this.cssVariable("theme");this.hasAttribute("pfe-theme")&&(e=this.getAttribute("pfe-theme"),this.cssVariable("theme",e)),this.context_set(e),[...t].map(t=>{t.connected&&t.context_set(e)})}context_set(t){let e=this.cssVariable("theme");e||(e=this.getAttribute("pfe-theme")),!e&&t&&(e=t),e&&this.hasAttribute("pfelement")&&this.setAttribute("on",e)}constructor(t,{type:e=null,delayRender:s=!1}={}){super(),this.connected=!1,this._pfeClass=t,this.tag=t.tag,this.props=t.properties,this.slots=t.slots,this._queue=[],this.template=document.createElement("template"),this.log("Constructing..."),this.attachShadow({mode:"open"}),e&&this._queueAction({type:"setProperty",data:{name:"pfeType",value:e}}),s||(this.log("Render..."),this.render(),this.log("Rendered.")),this.log("Constructed.")}connectedCallback(){this.connected=!0,this.log("Connecting..."),window.ShadyCSS&&(this.log("Styling..."),window.ShadyCSS.styleElement(this),this.log("Styled.")),!this.hasAttribute("pfelement")&&this.hasAttribute("on")&&console.warn(`${this.tag}${this.id?`[#${this.id}]`:""}: The "on" attribute is protected and should not be manually added to a component. The base class will manage this value for you on upgrade.`),this.classList.add("PFElement"),this.setAttribute("pfelement",""),"object"==typeof this.props&&(this._mapSchemaToProperties(this.tag,this.props),this.log("Properties attached.")),"object"==typeof this.slots&&(this._mapSchemaToSlots(this.tag,this.slots),this.log("Slots attached.")),this._queue.length&&this._processQueue(),this.context_update(),this.log("Connected.")}disconnectedCallback(){this.log("Disconnecting..."),this.connected=!1,this.log("Disconnected.")}attributeChangedCallback(t,e,s){if(!this._pfeClass.cascadingAttributes)return;const i=this._pfeClass.cascadingAttributes[t];i&&this._copyAttribute(t,i),"pfe-theme"===t&&this.context_update()}_copyAttribute(t,e){const s=[...this.querySelectorAll(e),...this.shadowRoot.querySelectorAll(e)],i=this.getAttribute(t),o=null==i?"removeAttribute":"setAttribute";for(const e of s)e[o](t,i)}_mapSchemaToProperties(t,e){this.log("Mapping properties..."),Object.keys(e).forEach(i=>{let o=e[i];if("object"==typeof o){let e=!0,n=i;if(this[i]=o,this[i].value=null,void 0!==this[i].prefixed&&(e=this[i].prefixed),e&&(n=`${s}${i}`),this.hasAttribute(n))this[i].value=this.getAttribute(n);else if(o.default){const e=this._hasDependency(t,o.options),s=!o.options||o.options&&!o.options.dependencies.length;(e||s)&&(this.setAttribute(n,o.default),this[i].value=o.default)}}}),this.log("Properties mapped.")}_hasDependency(t,e){let i=e?e.dependencies:[],o=!1;for(let e=0;e<i.length;e+=1){const n="slot"===i[e].type&&this.has_slots(`${t}--${i[e].id}`).length>0,h="attribute"===i[e].type&&this.getAttribute(`${s}${i[e].id}`);if(n||h){o=!0;break}}return o}_mapSchemaToSlots(t,e){this.log("Validate slots..."),Object.keys(e).forEach(s=>{let i=e[s];if("object"==typeof i){let e=!1,o=[];i.namedSlot?((o=this.has_slots(`${t}--${s}`)).length>0&&(i.nodes=o,e=!0),(o=this.has_slots(`${s}`)).length>0&&(i.nodes=o,e=!0)):(o=[...this.children].filter(t=>!t.hasAttribute("slot"))).length>0&&(i.nodes=o,e=!0),e?this.setAttribute(`has_${s}`,""):this.removeAttribute(`has_${s}`)}}),this.log("Slots validated.")}_queueAction(t){this._queue.push(t)}_processQueue(){this._queue.forEach(t=>{this[`_${t.type}`](t.data)}),this._queue=[]}_setProperty({name:t,value:e}){this[t]=e}static var(t,e=document.body){return window.getComputedStyle(e).getPropertyValue(t).trim()}var(t){return i.var(t,this)}render(){this.shadowRoot.innerHTML="",this.template.innerHTML=this.html,window.ShadyCSS&&window.ShadyCSS.prepareTemplate(this.template,this.tag),this.shadowRoot.appendChild(this.template.content.cloneNode(!0))}log(...t){i.log(`[${this.tag}]`,...t)}emitEvent(t,{bubbles:e=!0,cancelable:s=!1,composed:i=!1,detail:o={}}={}){this.log(`Custom event: ${t}`),this.dispatchEvent(new CustomEvent(t,{bubbles:e,cancelable:s,composed:i,detail:o}))}}!function(s){t=s;const i=window.WebComponents,o=i&&window.WebComponents.ready;!i||o?e():window.addEventListener("WebComponentsReady",e)}(i.log);export default i;
//# sourceMappingURL=pfelement.min.js.map
